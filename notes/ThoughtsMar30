- Real number induction:http://ucsd-pl.github.io/veridrone/induction/2016/02/17/real-induction.html#read-more
- Look at proofs for sel4.
- Language that describes the movements of a vehicle/spacecraft, w/ proofs that bad conditions
  (i.e., hitting an obstacle) are avoided while good ones (reaches destination) are reached
    - may be jumping too far too fast; how to break this down into layers that have their
      own proofs and aid the proofs above them?
- THOUGHT: Research use of hypervisors in aerospace/self driving vehicle applications;
  if big, could a toy hypervisor be built and have important properties proved?

- THOUGHT: Spacecraft/vehicles: Each sensor has one or more commands recommended at
           each time interval, by AI algo within each. Some commands may not control same ouptut component,
           in which case no problem. Of those that overlap components, some may not be contradictory.
           The remaining commands interfere and need to be chosen from by some central decision maker.
           So: how to make that choice, and how to guarantee that no matter what choice is made,
           certain safety/liveness constraints/guarantees are enforced/made?
           - Ex: LIDAR contradicts with camera

- THOUGHT: Proving in concurrency-dominated system. Maybe start with
  simple thread-based language, work on expanding this to either
  a more complex language or parallel circuits

- THOUGHT: Stop trying so hard to prove high-level aspects of spacecraft/vehicle direction,
           it's not possible in that sense b/c environment is always changing, done by AI etc.
           Instead develop something with corresponding proof that could be useful in
           either a vehicle or aerospace context.
           - Hypervisor is one idea, i.e. has its own actions but also own language (instruction set)
             to be used by domUs; prove both the language and actions correct (latter meaning, doesn't
             allow shared memory unless mutually approved, resources don't leak into each other,
             etc.)

- THOUGHT: Proving that a homomorphic encrypted-based service is not
  able to see the input, but is able to perform some operation on it
    - 2 sets of proofs: one for the enc/dec, another for the
      backend software itself.
    - Don't think only about websites, think about any low-level but
      critical interface between software/systems/chips. Ex: SWIFT banking interlink
    - Or, what about that F-35I? Israel wanted to plug and play their own software,
      and they'd want to keep the software secret. Could a CPU be able to
      apply instructions to a set of registers without knowing what those instructions are?
      - But then a chip could sit on the side and just diff the register changes, copying
        a log somewhere
      - Applied to cryptocurrency: node can check validity of signatures, sender/recipient,
        lock/unlock scripts, etc. and allow ledger to be updated accordingly, propagating
        transaction throught network, WITHOUT being able to see who is sending and receiving
        and how much. Ledger would need to be indexed by what? Can't by sender/receiver, and
        can't put amount.
          - Would need to learn: how does homomorphic encryption work,
            (I think this also involves garbled circuits), and can any of that
            be articulated in a formal theorem prover?

